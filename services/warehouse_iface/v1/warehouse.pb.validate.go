// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: warehouse_iface/v1/warehouse.proto

package warehouse_iface

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ExpenseReportDailyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseReportDailyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseReportDailyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseReportDailyReqMultiError, or nil if none found.
func (m *ExpenseReportDailyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseReportDailyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for WarehouseId

	if len(errors) > 0 {
		return ExpenseReportDailyReqMultiError(errors)
	}

	return nil
}

// ExpenseReportDailyReqMultiError is an error wrapping multiple validation
// errors returned by ExpenseReportDailyReq.ValidateAll() if the designated
// constraints aren't met.
type ExpenseReportDailyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseReportDailyReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseReportDailyReqMultiError) AllErrors() []error { return m }

// ExpenseReportDailyReqValidationError is the validation error returned by
// ExpenseReportDailyReq.Validate if the designated constraints aren't met.
type ExpenseReportDailyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseReportDailyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseReportDailyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseReportDailyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseReportDailyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseReportDailyReqValidationError) ErrorName() string {
	return "ExpenseReportDailyReqValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseReportDailyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseReportDailyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseReportDailyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseReportDailyReqValidationError{}

// Validate checks the field values on ReportDaily with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportDaily) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportDaily with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportDailyMultiError, or
// nil if none found.
func (m *ReportDaily) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportDaily) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartDate

	// no validation rules for EndDate

	// no validation rules for Expense

	// no validation rules for Income

	// no validation rules for SystemDiffAmount

	// no validation rules for ActualDiffAmount

	// no validation rules for ErrDiffAmount

	if len(errors) > 0 {
		return ReportDailyMultiError(errors)
	}

	return nil
}

// ReportDailyMultiError is an error wrapping multiple validation errors
// returned by ReportDaily.ValidateAll() if the designated constraints aren't met.
type ReportDailyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportDailyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportDailyMultiError) AllErrors() []error { return m }

// ReportDailyValidationError is the validation error returned by
// ReportDaily.Validate if the designated constraints aren't met.
type ReportDailyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportDailyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportDailyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportDailyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportDailyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportDailyValidationError) ErrorName() string { return "ReportDailyValidationError" }

// Error satisfies the builtin error interface
func (e ReportDailyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportDaily.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportDailyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportDailyValidationError{}

// Validate checks the field values on ExpenseReportDailyRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseReportDailyRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseReportDailyRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseReportDailyResMultiError, or nil if none found.
func (m *ExpenseReportDailyRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseReportDailyRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpenseReportDailyResValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpenseReportDailyResValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpenseReportDailyResValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExpenseReportDailyResMultiError(errors)
	}

	return nil
}

// ExpenseReportDailyResMultiError is an error wrapping multiple validation
// errors returned by ExpenseReportDailyRes.ValidateAll() if the designated
// constraints aren't met.
type ExpenseReportDailyResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseReportDailyResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseReportDailyResMultiError) AllErrors() []error { return m }

// ExpenseReportDailyResValidationError is the validation error returned by
// ExpenseReportDailyRes.Validate if the designated constraints aren't met.
type ExpenseReportDailyResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseReportDailyResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseReportDailyResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseReportDailyResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseReportDailyResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseReportDailyResValidationError) ErrorName() string {
	return "ExpenseReportDailyResValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseReportDailyResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseReportDailyRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseReportDailyResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseReportDailyResValidationError{}

// Validate checks the field values on ExpenseHistoryListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseHistoryListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseHistoryListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseHistoryListReqMultiError, or nil if none found.
func (m *ExpenseHistoryListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseHistoryListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for WarehouseId

	// no validation rules for IsOpsAccount

	// no validation rules for ExpenseType

	// no validation rules for StartDate

	// no validation rules for EndDate

	if len(errors) > 0 {
		return ExpenseHistoryListReqMultiError(errors)
	}

	return nil
}

// ExpenseHistoryListReqMultiError is an error wrapping multiple validation
// errors returned by ExpenseHistoryListReq.ValidateAll() if the designated
// constraints aren't met.
type ExpenseHistoryListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseHistoryListReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseHistoryListReqMultiError) AllErrors() []error { return m }

// ExpenseHistoryListReqValidationError is the validation error returned by
// ExpenseHistoryListReq.Validate if the designated constraints aren't met.
type ExpenseHistoryListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseHistoryListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseHistoryListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseHistoryListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseHistoryListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseHistoryListReqValidationError) ErrorName() string {
	return "ExpenseHistoryListReqValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseHistoryListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseHistoryListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseHistoryListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseHistoryListReqValidationError{}

// Validate checks the field values on ExpenseHistoryListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseHistoryListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseHistoryListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseHistoryListResMultiError, or nil if none found.
func (m *ExpenseHistoryListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseHistoryListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpenseHistoryListResValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpenseHistoryListResValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpenseHistoryListResValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExpenseHistoryListResMultiError(errors)
	}

	return nil
}

// ExpenseHistoryListResMultiError is an error wrapping multiple validation
// errors returned by ExpenseHistoryListRes.ValidateAll() if the designated
// constraints aren't met.
type ExpenseHistoryListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseHistoryListResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseHistoryListResMultiError) AllErrors() []error { return m }

// ExpenseHistoryListResValidationError is the validation error returned by
// ExpenseHistoryListRes.Validate if the designated constraints aren't met.
type ExpenseHistoryListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseHistoryListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseHistoryListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseHistoryListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseHistoryListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseHistoryListResValidationError) ErrorName() string {
	return "ExpenseHistoryListResValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseHistoryListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseHistoryListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseHistoryListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseHistoryListResValidationError{}

// Validate checks the field values on WarehouseExpenseHistory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WarehouseExpenseHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WarehouseExpenseHistory with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WarehouseExpenseHistoryMultiError, or nil if none found.
func (m *WarehouseExpenseHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *WarehouseExpenseHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AccountId

	// no validation rules for WarehouseId

	// no validation rules for IsOpsAccount

	// no validation rules for ExpenseType

	// no validation rules for Amount

	if len(errors) > 0 {
		return WarehouseExpenseHistoryMultiError(errors)
	}

	return nil
}

// WarehouseExpenseHistoryMultiError is an error wrapping multiple validation
// errors returned by WarehouseExpenseHistory.ValidateAll() if the designated
// constraints aren't met.
type WarehouseExpenseHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WarehouseExpenseHistoryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WarehouseExpenseHistoryMultiError) AllErrors() []error { return m }

// WarehouseExpenseHistoryValidationError is the validation error returned by
// WarehouseExpenseHistory.Validate if the designated constraints aren't met.
type WarehouseExpenseHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WarehouseExpenseHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WarehouseExpenseHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WarehouseExpenseHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WarehouseExpenseHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WarehouseExpenseHistoryValidationError) ErrorName() string {
	return "WarehouseExpenseHistoryValidationError"
}

// Error satisfies the builtin error interface
func (e WarehouseExpenseHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWarehouseExpenseHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WarehouseExpenseHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WarehouseExpenseHistoryValidationError{}

// Validate checks the field values on ExpenseHistoryAddReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseHistoryAddReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseHistoryAddReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseHistoryAddReqMultiError, or nil if none found.
func (m *ExpenseHistoryAddReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseHistoryAddReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for WarehouseId

	// no validation rules for CreatedById

	// no validation rules for ExpenseType

	// no validation rules for Amount

	// no validation rules for Note

	if len(errors) > 0 {
		return ExpenseHistoryAddReqMultiError(errors)
	}

	return nil
}

// ExpenseHistoryAddReqMultiError is an error wrapping multiple validation
// errors returned by ExpenseHistoryAddReq.ValidateAll() if the designated
// constraints aren't met.
type ExpenseHistoryAddReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseHistoryAddReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseHistoryAddReqMultiError) AllErrors() []error { return m }

// ExpenseHistoryAddReqValidationError is the validation error returned by
// ExpenseHistoryAddReq.Validate if the designated constraints aren't met.
type ExpenseHistoryAddReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseHistoryAddReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseHistoryAddReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseHistoryAddReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseHistoryAddReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseHistoryAddReqValidationError) ErrorName() string {
	return "ExpenseHistoryAddReqValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseHistoryAddReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseHistoryAddReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseHistoryAddReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseHistoryAddReqValidationError{}

// Validate checks the field values on ExpenseHistoryAddRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseHistoryAddRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseHistoryAddRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseHistoryAddResMultiError, or nil if none found.
func (m *ExpenseHistoryAddRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseHistoryAddRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ExpenseHistoryAddResMultiError(errors)
	}

	return nil
}

// ExpenseHistoryAddResMultiError is an error wrapping multiple validation
// errors returned by ExpenseHistoryAddRes.ValidateAll() if the designated
// constraints aren't met.
type ExpenseHistoryAddResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseHistoryAddResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseHistoryAddResMultiError) AllErrors() []error { return m }

// ExpenseHistoryAddResValidationError is the validation error returned by
// ExpenseHistoryAddRes.Validate if the designated constraints aren't met.
type ExpenseHistoryAddResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseHistoryAddResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseHistoryAddResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseHistoryAddResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseHistoryAddResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseHistoryAddResValidationError) ErrorName() string {
	return "ExpenseHistoryAddResValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseHistoryAddResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseHistoryAddRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseHistoryAddResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseHistoryAddResValidationError{}

// Validate checks the field values on ExpenseHistoryEditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseHistoryEditReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseHistoryEditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseHistoryEditReqMultiError, or nil if none found.
func (m *ExpenseHistoryEditReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseHistoryEditReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HistId

	// no validation rules for AccountId

	// no validation rules for WarehouseId

	// no validation rules for CreatedById

	// no validation rules for ExpenseType

	// no validation rules for Amount

	// no validation rules for Note

	if len(errors) > 0 {
		return ExpenseHistoryEditReqMultiError(errors)
	}

	return nil
}

// ExpenseHistoryEditReqMultiError is an error wrapping multiple validation
// errors returned by ExpenseHistoryEditReq.ValidateAll() if the designated
// constraints aren't met.
type ExpenseHistoryEditReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseHistoryEditReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseHistoryEditReqMultiError) AllErrors() []error { return m }

// ExpenseHistoryEditReqValidationError is the validation error returned by
// ExpenseHistoryEditReq.Validate if the designated constraints aren't met.
type ExpenseHistoryEditReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseHistoryEditReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseHistoryEditReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseHistoryEditReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseHistoryEditReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseHistoryEditReqValidationError) ErrorName() string {
	return "ExpenseHistoryEditReqValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseHistoryEditReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseHistoryEditReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseHistoryEditReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseHistoryEditReqValidationError{}

// Validate checks the field values on ExpenseHistoryEditRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseHistoryEditRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseHistoryEditRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseHistoryEditResMultiError, or nil if none found.
func (m *ExpenseHistoryEditRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseHistoryEditRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ExpenseHistoryEditResMultiError(errors)
	}

	return nil
}

// ExpenseHistoryEditResMultiError is an error wrapping multiple validation
// errors returned by ExpenseHistoryEditRes.ValidateAll() if the designated
// constraints aren't met.
type ExpenseHistoryEditResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseHistoryEditResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseHistoryEditResMultiError) AllErrors() []error { return m }

// ExpenseHistoryEditResValidationError is the validation error returned by
// ExpenseHistoryEditRes.Validate if the designated constraints aren't met.
type ExpenseHistoryEditResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseHistoryEditResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseHistoryEditResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseHistoryEditResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseHistoryEditResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseHistoryEditResValidationError) ErrorName() string {
	return "ExpenseHistoryEditResValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseHistoryEditResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseHistoryEditRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseHistoryEditResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseHistoryEditResValidationError{}

// Validate checks the field values on ExpenseAccountGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseAccountGetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseAccountGetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseAccountGetRequestMultiError, or nil if none found.
func (m *ExpenseAccountGetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseAccountGetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for WarehouseId

	// no validation rules for IsOpsAccount

	if len(errors) > 0 {
		return ExpenseAccountGetRequestMultiError(errors)
	}

	return nil
}

// ExpenseAccountGetRequestMultiError is an error wrapping multiple validation
// errors returned by ExpenseAccountGetRequest.ValidateAll() if the designated
// constraints aren't met.
type ExpenseAccountGetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseAccountGetRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseAccountGetRequestMultiError) AllErrors() []error { return m }

// ExpenseAccountGetRequestValidationError is the validation error returned by
// ExpenseAccountGetRequest.Validate if the designated constraints aren't met.
type ExpenseAccountGetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseAccountGetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseAccountGetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseAccountGetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseAccountGetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseAccountGetRequestValidationError) ErrorName() string {
	return "ExpenseAccountGetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseAccountGetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseAccountGetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseAccountGetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseAccountGetRequestValidationError{}

// Validate checks the field values on ExpenseAccountCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseAccountCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseAccountCreateReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseAccountCreateReqMultiError, or nil if none found.
func (m *ExpenseAccountCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseAccountCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DomainId

	// no validation rules for WarehouseId

	// no validation rules for AccountTypeId

	// no validation rules for Name

	// no validation rules for NumberId

	// no validation rules for IsOpsAccount

	if len(errors) > 0 {
		return ExpenseAccountCreateReqMultiError(errors)
	}

	return nil
}

// ExpenseAccountCreateReqMultiError is an error wrapping multiple validation
// errors returned by ExpenseAccountCreateReq.ValidateAll() if the designated
// constraints aren't met.
type ExpenseAccountCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseAccountCreateReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseAccountCreateReqMultiError) AllErrors() []error { return m }

// ExpenseAccountCreateReqValidationError is the validation error returned by
// ExpenseAccountCreateReq.Validate if the designated constraints aren't met.
type ExpenseAccountCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseAccountCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseAccountCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseAccountCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseAccountCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseAccountCreateReqValidationError) ErrorName() string {
	return "ExpenseAccountCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseAccountCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseAccountCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseAccountCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseAccountCreateReqValidationError{}

// Validate checks the field values on ExpenseAccountEditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseAccountEditReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseAccountEditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseAccountEditReqMultiError, or nil if none found.
func (m *ExpenseAccountEditReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseAccountEditReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DomainId

	// no validation rules for AccountId

	// no validation rules for WarehouseId

	// no validation rules for AccountTypeId

	// no validation rules for IsOpsAccount

	// no validation rules for Name

	// no validation rules for NumberId

	if len(errors) > 0 {
		return ExpenseAccountEditReqMultiError(errors)
	}

	return nil
}

// ExpenseAccountEditReqMultiError is an error wrapping multiple validation
// errors returned by ExpenseAccountEditReq.ValidateAll() if the designated
// constraints aren't met.
type ExpenseAccountEditReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseAccountEditReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseAccountEditReqMultiError) AllErrors() []error { return m }

// ExpenseAccountEditReqValidationError is the validation error returned by
// ExpenseAccountEditReq.Validate if the designated constraints aren't met.
type ExpenseAccountEditReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseAccountEditReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseAccountEditReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseAccountEditReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseAccountEditReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseAccountEditReqValidationError) ErrorName() string {
	return "ExpenseAccountEditReqValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseAccountEditReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseAccountEditReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseAccountEditReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseAccountEditReqValidationError{}

// Validate checks the field values on ExpenseAccountGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseAccountGetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseAccountGetResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseAccountGetResponseMultiError, or nil if none found.
func (m *ExpenseAccountGetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseAccountGetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for WarehouseId

	// no validation rules for AccountTypeId

	// no validation rules for Name

	// no validation rules for NumberId

	// no validation rules for IsOpsAccount

	// no validation rules for Disabled

	if len(errors) > 0 {
		return ExpenseAccountGetResponseMultiError(errors)
	}

	return nil
}

// ExpenseAccountGetResponseMultiError is an error wrapping multiple validation
// errors returned by ExpenseAccountGetResponse.ValidateAll() if the
// designated constraints aren't met.
type ExpenseAccountGetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseAccountGetResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseAccountGetResponseMultiError) AllErrors() []error { return m }

// ExpenseAccountGetResponseValidationError is the validation error returned by
// ExpenseAccountGetResponse.Validate if the designated constraints aren't met.
type ExpenseAccountGetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseAccountGetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseAccountGetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseAccountGetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseAccountGetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseAccountGetResponseValidationError) ErrorName() string {
	return "ExpenseAccountGetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseAccountGetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseAccountGetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseAccountGetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseAccountGetResponseValidationError{}

// Validate checks the field values on ExpenseAccountListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseAccountListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseAccountListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseAccountListRequestMultiError, or nil if none found.
func (m *ExpenseAccountListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseAccountListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WarehouseId

	// no validation rules for NumberId

	// no validation rules for Name

	// no validation rules for IsOpsAccount

	if len(errors) > 0 {
		return ExpenseAccountListRequestMultiError(errors)
	}

	return nil
}

// ExpenseAccountListRequestMultiError is an error wrapping multiple validation
// errors returned by ExpenseAccountListRequest.ValidateAll() if the
// designated constraints aren't met.
type ExpenseAccountListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseAccountListRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseAccountListRequestMultiError) AllErrors() []error { return m }

// ExpenseAccountListRequestValidationError is the validation error returned by
// ExpenseAccountListRequest.Validate if the designated constraints aren't met.
type ExpenseAccountListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseAccountListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseAccountListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseAccountListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseAccountListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseAccountListRequestValidationError) ErrorName() string {
	return "ExpenseAccountListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseAccountListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseAccountListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseAccountListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseAccountListRequestValidationError{}

// Validate checks the field values on ExpenseAccountListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpenseAccountListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseAccountListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpenseAccountListResMultiError, or nil if none found.
func (m *ExpenseAccountListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseAccountListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpenseAccountListResValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpenseAccountListResValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpenseAccountListResValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExpenseAccountListResMultiError(errors)
	}

	return nil
}

// ExpenseAccountListResMultiError is an error wrapping multiple validation
// errors returned by ExpenseAccountListRes.ValidateAll() if the designated
// constraints aren't met.
type ExpenseAccountListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseAccountListResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseAccountListResMultiError) AllErrors() []error { return m }

// ExpenseAccountListResValidationError is the validation error returned by
// ExpenseAccountListRes.Validate if the designated constraints aren't met.
type ExpenseAccountListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseAccountListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseAccountListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseAccountListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseAccountListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseAccountListResValidationError) ErrorName() string {
	return "ExpenseAccountListResValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseAccountListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseAccountListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseAccountListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseAccountListResValidationError{}

// Validate checks the field values on EmptyReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyReqMultiError, or nil
// if none found.
func (m *EmptyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyReqMultiError(errors)
	}

	return nil
}

// EmptyReqMultiError is an error wrapping multiple validation errors returned
// by EmptyReq.ValidateAll() if the designated constraints aren't met.
type EmptyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyReqMultiError) AllErrors() []error { return m }

// EmptyReqValidationError is the validation error returned by
// EmptyReq.Validate if the designated constraints aren't met.
type EmptyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyReqValidationError) ErrorName() string { return "EmptyReqValidationError" }

// Error satisfies the builtin error interface
func (e EmptyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyReqValidationError{}

// Validate checks the field values on EmptyRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyResMultiError, or nil
// if none found.
func (m *EmptyRes) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return EmptyResMultiError(errors)
	}

	return nil
}

// EmptyResMultiError is an error wrapping multiple validation errors returned
// by EmptyRes.ValidateAll() if the designated constraints aren't met.
type EmptyResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyResMultiError) AllErrors() []error { return m }

// EmptyResValidationError is the validation error returned by
// EmptyRes.Validate if the designated constraints aren't met.
type EmptyResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyResValidationError) ErrorName() string { return "EmptyResValidationError" }

// Error satisfies the builtin error interface
func (e EmptyResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyResValidationError{}
